## 链表
单向链表
环形链表（存储数目固定的数据）
双向链表

## 数组

## 栈 (LIFO)
Last in， first out

深度优先搜索算法，通常会选择最新的数据作为候补顶点。在候补顶点的管理上就可以使用栈。

## 队列 (FIFO)
Fist in， first out

广度优先搜索算法，通常就会从搜索候补中选择最早的数据作为下一个顶点。此时，在候补顶点的管理上就可以使用队列。

## 哈希表
哈希表在数据存储上的灵活性和数据查询上的高效性

在哈希表这种数据结构中，使用在“哈希函数”，可以使数据的查询效率得到显著提升。

哈希表存储的是由键（key）和值（value）组成的数据。

在哈希表中，可以利用哈希函数快速访问到数组中的目标数据。
如果发生哈希冲突，就使用链表进行存储。
如果数组的空间太小，使用哈希表的时候就容易发生冲突，线性查找的使用频率也会更高；反过来，如果数组的空间太大，就会出现很多空箱子，造成内存的浪费。
因此，给数组设定合适的空间非常重要。


在存储数据的过程中，如果发生冲突，可以利用链表在已有数据的后面插入新数据来解决冲突。这种方法被称为“链地址法”。
除了链地址法以外，还有几种解决冲突的方法。
其中，应用较为广泛的是“开放地址法”。
这种方法是指当冲突发生时，立刻计算出一个候补地址（ 数组上的位置） 并将数据存进去。如果仍然有冲突，便继续计算下一个候补地址，直到有空地址为止。
可以通过多次使用哈希函数或“线性探测法” 等方法计算候补地址。

在把哈希表应用于密码等安全方面时需要留意“无法根据哈希值推算出原值”


## 堆

堆是一种图的树形结构。
被用于实现“优先队列”（ priority queues）。
优先队列是一种数据结构，可以自由添加数据，但取出数据时要从最小值开始按顺序取出。
在堆的树形结构中，各个顶点被称为“结点”（ node），数据就存储在这些结点中。


结点内的数字就是存储的数据。
堆中的每个结点最多有两个子结点。
树的形状取决于数据的个数。
结点的排列顺序为从上到下，同一行里则为从左到右。


在堆中存储数据时必须遵守这样一条规则 ：
子结点必定大于父结点。因此，最小值被存储在顶端的根结点中。
往堆中添加数据时，为了遵守这条规则，一般会把新数据放在最下面一行靠左
的位置。
当最下面一行里没有多余空间时，就再往下另起一行，把数据加在这一行的最左端。


从堆中取出数据时，取出的是最上面的数据。
这样，堆中就能始终保持最上面的数据最小。
由于最上面的数据被取出，因此堆的结构也需要重新调整。
将最后的数据移动到最顶端。
如果子结点的数字小于父结点的，就将父结点与其左右两个子结点中较小的一个进行交换。


堆中最顶端的数据始终最小，所以无论数据量有多少，取出最小值的时间复杂度都为 O(1)。
另外，因为取出数据后需要将最后的数据移到最顶端，然后一边比较它与子结点数据的大小，一边往下移动，所以取出数据需要的运行时间和树的高度成正比。假设数据量为n，根据堆的形状特点可知树的高度为 log2n ，那么重构树的时间复杂度便为 O(logn)。

添加数据也一样。在堆的最后添加数据后，数据会一边比较它与父结点数据的大小，一边往上移动，直到满足堆的条件为止，所以添加数据需要的运行时间与树的高度成正比，也是 O(logn)。


应用：
如果需要频繁地从管理的数据中取出最小值，那么使用堆来操作会非常方便。
比如狄克斯特拉算法，每一步都需要从候补顶点中选择距离起点最近的那个顶点。此时，在顶点的选择上就可以用到堆。

## 二叉查找树 （二叉搜索树/二叉排序树）

二叉查找树（又叫作二叉搜索树或二叉排序树）是一种数据结构。
采用了图的树形结构。

数据存储于二叉查找树的各个结点中。
每个结点最多有两个子结点。

二叉查找树有两个性质。
第一个是每个结点的值均大于其左子树上任意一个结点的值。
第二个是每个结点的值均小于其右子树上任意一个结点的值。

根据这两个性质可以得到以下结论。
首先，二叉查找树的最小结点要从顶端开始，往其左下的末端寻找。
反过来，二叉查找树的最大结点要从顶端开始，往其右下的末端寻找。

往二叉查找树中添加数据：
首先，从二叉查找树的顶端结点开始寻找添加数字的位置。
将想要添加的数据与该结点中的值进行比较，小于它则往左移，大于它则往右移。


在二叉查找树中删除结点：
如果需要删除的结点没有子结点，直接删掉该结点即可。
如果需要删除的结点只有一个子结点，那么先删掉目标结点，然后把子结点移到被删除结点的位置上即可。
如果需要删除的结点有两个子结点，那么先删掉目标结点，然后在被删除结点的左子树中寻找最大结点，（根据二叉查找树的性质可知，移动“右子树中的最小结点”也没有问题）最后将最大结点移到被删除结点的位置上。这样一来，就能在满足二叉查找树性质的前提下删除结点了。如果需要移动的结点（此处为4）还有子结点，就递归执行前面的操作。

在二叉查找树中查找结点：
从二叉查找树的顶端结点开始往下查找。、
和添加数据时一样，把 12和结点中的值进行比较，小于该结点的值则往左移，大于则往右移。


可以把二叉查找树当作是二分查找算法思想的树形结构体现。
因为它具有前面提到的那两个性质，所以在查找数据或寻找适合添加数据的位置时，只要将其和现有的数据比较大小，就可以根据比较结果得知该往哪移
动了。
比较的次数取决于树的高度。
所以如果结点数为n，而且树的形状又较为均衡的话，比较大小和移动的次数最多就是 log2n。因此，时间复杂度为 O(logn)。
但是，如果树的形状朝单侧纵向延伸，树就会变得很高，此时时间复杂度也就变成了O(n)。

扩展：
有很多以二叉查找树为基础扩展的数据结构，比如“平衡二叉查找树”。
这种数据结构可以修正形状不均衡的树，让其始终保持均衡形态，以提高查找效率。

另外，虽然文中介绍的二叉查找树中一个结点最多有两个子结点，但我们可以把子结点数扩展为 m（ m 为预先设定好的常数）。像这种子结点数可以自由设定，并且形状均衡的树便是B树。


